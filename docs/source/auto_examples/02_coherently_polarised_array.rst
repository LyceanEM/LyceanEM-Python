
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\02_coherently_polarised_array.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_02_coherently_polarised_array.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_02_coherently_polarised_array.py:


Modelling a Coherently Polarised Aperture
======================================================

This example uses the frequency domain :func:`lyceanem.models.frequency_domain.calculate_farfield` function to predict
the farfield pattern for a linearly polarised aperture. This could represent an antenna array without any beamforming
weights.

.. GENERATED FROM PYTHON SOURCE LINES 13-17

.. code-block:: Python

    import copy

    import numpy as np
    import meshio







.. GENERATED FROM PYTHON SOURCE LINES 18-27

Setting Farfield Resolution and Wavelength
-------------------------------------------
LyceanEM uses Elevation and Azimuth to record spherical coordinates, ranging from -180 to 180 degrees in azimuth,
and from -90 to 90 degrees in elevation. In order to launch the aperture projection function, the resolution in
both azimuth and elevation is requried.
In order to ensure a fast example, 37 points have been used here for both, giving a total of 1369 farfield points.

The wavelength of interest is also an important variable for antenna array analysis, so we set it now for 10GHz,
an X band aperture.

.. GENERATED FROM PYTHON SOURCE LINES 27-32

.. code-block:: Python


    az_res = 181
    elev_res = 181
    wavelength = 3e8 / 10e9








.. GENERATED FROM PYTHON SOURCE LINES 33-37

Geometries
------------------------
In order to make things easy to start, an example geometry has been included within LyceanEM for a UAV, and the
:class:`open3d.geometry.TriangleMesh` structures can be accessed by importing the data subpackage

.. GENERATED FROM PYTHON SOURCE LINES 37-43

.. code-block:: Python

    import lyceanem.tests.reflectordata as data

    body, array, source_coords = data.exampleUAV(10e9)










.. GENERATED FROM PYTHON SOURCE LINES 44-45

# .. image:: ../_static/open3d_structure.png

.. GENERATED FROM PYTHON SOURCE LINES 45-68

.. code-block:: Python


    # crop the inner surface of the array trianglemesh (not strictly required, as the UAV main body provides blocking to
    # the hidden surfaces, but correctly an aperture will only have an outer face.
    surface_array = copy.deepcopy(array)
    surface_array.cells[0].data = np.asarray(array.cells[0].data)[: (array.cells[0].data).shape[0] // 2, :]

    surface_array.cell_data["Normals"] = np.array(array.cell_data["Normals"])[: (array.cells[0].data).shape[0] // 2]

    from lyceanem.base_classes import structures

    blockers = structures([body, array])

    from lyceanem.models.frequency_domain import calculate_farfield




    import pyvista as pv


    source_points = surface_array.points









.. GENERATED FROM PYTHON SOURCE LINES 69-70

.. image:: ../_static/sourcecloudfromshapeuav.png

.. GENERATED FROM PYTHON SOURCE LINES 72-77

Drawbacks of :func:`lyceanem.geometry.geometryfunctions.sourcecloudfromshape`
------------------------------------------------------------------------------
As can be seen by comparing the two source point sets, :func:`lyceanem.geometry.geometryfunctions.sourcecloudfromshape`
has a significant drawback when used for complex sharply curved antenna arrays, as the poisson disk sampling method
does not produce consistently spaced results.

.. GENERATED FROM PYTHON SOURCE LINES 77-92

.. code-block:: Python


    desired_E_axis = np.zeros((1, 3), dtype=np.float32)
    desired_E_axis[0, 1] = 1.0

    Etheta, Ephi = calculate_farfield(
        source_coords,
        blockers,
        desired_E_axis,
        az_range=np.linspace(-180, 180, az_res),
        el_range=np.linspace(-90, 90, elev_res),
        wavelength=wavelength,
        farfield_distance=20,
        project_vectors=True,
    )





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    C:\Users\lycea\PycharmProjects\LyceanEM-Python\lyceanem\electromagnetics\empropagation.py:3669: ComplexWarning: Casting complex values to real discards the imaginary part
      uvn_axes[2, :] = point_vector
    C:\Users\lycea\PycharmProjects\LyceanEM-Python\lyceanem\electromagnetics\empropagation.py:3686: ComplexWarning: Casting complex values to real discards the imaginary part
      uvn_axes[0, :] = np.cross(local_axes[2, :], point_vector) / np.linalg.norm(
    C:\Users\lycea\PycharmProjects\LyceanEM-Python\lyceanem\electromagnetics\empropagation.py:3708: ComplexWarning: Casting complex values to real discards the imaginary part
      uvn_axes[1, :] = np.cross(point_vector, uvn_axes[0, :]) / np.linalg.norm(
    sources shape (67, 3)
    sinks shape (32761, 3)
    environment_points shape (0, 3)




.. GENERATED FROM PYTHON SOURCE LINES 93-101

Storing and Manipulating Antenna Patterns
---------------------------------------------
The resultant antenna pattern can be stored in :class:`lyceanem.base.antenna_pattern` as it has been modelled as one
distributed aperture, the advantage of this class is the integrated display, conversion and export functions. It is
very simple to define, and save the pattern, and then display with a call
to :func:`lyceanem.base.antenna_pattern.display_pattern`. This produces 3D polar plots which can be manipulated to
give a better view of the whole pattern, but if contour plots are required, then this can also be produced by passing
plottype='Contour' to the function.

.. GENERATED FROM PYTHON SOURCE LINES 101-112

.. code-block:: Python


    from lyceanem.base_classes import antenna_pattern

    UAV_Static_Pattern = antenna_pattern(
        azimuth_resolution=az_res, elevation_resolution=elev_res
    )
    UAV_Static_Pattern.pattern[:, :, 0] = Etheta
    UAV_Static_Pattern.pattern[:, :, 0] = Ephi

    UAV_Static_Pattern.display_pattern()




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/images/sphx_glr_02_coherently_polarised_array_001.png
         :alt: Etheta
         :srcset: /auto_examples/images/sphx_glr_02_coherently_polarised_array_001.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/images/sphx_glr_02_coherently_polarised_array_002.png
         :alt: Ephi
         :srcset: /auto_examples/images/sphx_glr_02_coherently_polarised_array_002.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    C:\Users\lycea\PycharmProjects\LyceanEM-Python\lyceanem\electromagnetics\beamforming.py:1100: RuntimeWarning: divide by zero encountered in log10
      logdata = 20 * np.log10(data)
    C:\Users\lycea\PycharmProjects\LyceanEM-Python\lyceanem\electromagnetics\beamforming.py:1103: RuntimeWarning: invalid value encountered in subtract
      logdata -= np.nanmax(logdata)




.. GENERATED FROM PYTHON SOURCE LINES 113-115

.. image:: ../_static/sphx_glr_02_coherently_polarised_array_001.png
.. image:: ../_static/sphx_glr_02_coherently_polarised_array_002.png

.. GENERATED FROM PYTHON SOURCE LINES 115-118

.. code-block:: Python


    UAV_Static_Pattern.display_pattern(plottype="Contour")




.. rst-class:: sphx-glr-horizontal


    *

      .. image-sg:: /auto_examples/images/sphx_glr_02_coherently_polarised_array_003.png
         :alt: Etheta
         :srcset: /auto_examples/images/sphx_glr_02_coherently_polarised_array_003.png
         :class: sphx-glr-multi-img

    *

      .. image-sg:: /auto_examples/images/sphx_glr_02_coherently_polarised_array_004.png
         :alt: Ephi
         :srcset: /auto_examples/images/sphx_glr_02_coherently_polarised_array_004.png
         :class: sphx-glr-multi-img


.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    C:\Users\lycea\.conda\envs\SpaceBasedSolar\lib\site-packages\matplotlib\contour.py:1479: UserWarning: Warning: converting a masked element to nan.
      self.zmax = float(z.max())
    C:\Users\lycea\.conda\envs\SpaceBasedSolar\lib\site-packages\matplotlib\contour.py:1480: UserWarning: Warning: converting a masked element to nan.
      self.zmin = float(z.min())
    C:\Users\lycea\PycharmProjects\LyceanEM-Python\lyceanem\electromagnetics\beamforming.py:1227: UserWarning: No contour levels were found within the data range.
      CS4 = ax.contour(




.. GENERATED FROM PYTHON SOURCE LINES 119-121

.. image:: ../_static/sphx_glr_02_coherently_polarised_array_003.png
.. image:: ../_static/sphx_glr_02_coherently_polarised_array_004.png


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 23.464 seconds)


.. _sphx_glr_download_auto_examples_02_coherently_polarised_array.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 02_coherently_polarised_array.ipynb <02_coherently_polarised_array.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 02_coherently_polarised_array.py <02_coherently_polarised_array.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
