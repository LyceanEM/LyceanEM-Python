
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples\03_frequency_domain_channel_modelling.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_03_frequency_domain_channel_modelling.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_03_frequency_domain_channel_modelling.py:


Modelling a Physical Channel in the Frequency Domain
======================================================

This example uses the frequency domain :func:`lyceanem.models.frequency_domain.calculate_scattering` function to
predict the scattering parameters for the frequency and environment included in the model.
This model allows for a very wide range of antennas and antenna arrays to be considered, but for simplicity only horn
antennas will be included in this example. The simplest case would be a single source point and single receive point,
rather than an aperture antenna such as a horn.

.. GENERATED FROM PYTHON SOURCE LINES 16-20

.. code-block:: Python



    import numpy as np


.. GENERATED FROM PYTHON SOURCE LINES 21-24

Frequency and Mesh Resolution
------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 24-28

.. code-block:: Python

    freq = np.asarray(24.0e9)
    wavelength = 3e8 / freq
    mesh_resolution = 0.5 * wavelength


.. GENERATED FROM PYTHON SOURCE LINES 29-32

Setup transmitters and receivers
-----------------------------------


.. GENERATED FROM PYTHON SOURCE LINES 32-44

.. code-block:: Python

    import lyceanem.geometry.targets as TL
    import lyceanem.geometry.geometryfunctions as GF


    transmit_horn_structure, transmitting_antenna_surface_coords = TL.meshedHorn(
        58e-3, 58e-3, 128e-3, 2e-3, 0.21, mesh_resolution
    )

    receive_horn_structure, receiving_antenna_surface_coords = TL.meshedHorn(
        58e-3, 58e-3, 128e-3, 2e-3, 0.21, mesh_resolution
    )


.. GENERATED FROM PYTHON SOURCE LINES 45-50

Position Transmitter
----------------------
rotate the transmitting antenna to the desired orientation, and then translate to final position.
:func:`lyceanem.geometryfunctions.mesh_rotate` and :func:`lyceanem.geometryfunctions.mesh_translate` are used to achive this


.. GENERATED FROM PYTHON SOURCE LINES 50-67

.. code-block:: Python

    rotation_vector1 = np.radians(np.asarray([90.0, 0.0, 0.0]))
    rotation_vector2 = np.radians(np.asarray([0.0, 0.0, -90.0]))
    rotation_vector3 = np.radians(np.asarray([0.0, 0.0, 90.0]))
    transmit_horn_structure = GF.mesh_rotate(
        transmit_horn_structure,
        rotation_vector1
    )
    transmit_horn_structure = GF.mesh_rotate(transmit_horn_structure,rotation_vector2)

    transmit_horn_structure = GF.mesh_translate(transmit_horn_structure,np.asarray([2.529, 0, 0]))

    transmitting_antenna_surface_coords = GF.mesh_rotate(transmitting_antenna_surface_coords,rotation_vector1)

    transmitting_antenna_surface_coords = GF.mesh_rotate(
        transmitting_antenna_surface_coords,rotation_vector2)

    transmitting_antenna_surface_coords = GF.mesh_translate(transmitting_antenna_surface_coords,np.asarray([2.529, 0, 0]))

.. GENERATED FROM PYTHON SOURCE LINES 68-71

Position Receiver
------------------
rotate the receiving horn to desired orientation and translate to final position.

.. GENERATED FROM PYTHON SOURCE LINES 71-81

.. code-block:: Python


    receive_horn_structure = GF.mesh_rotate(receive_horn_structure,rotation_vector1)
    #receive_horn_structure = GF.mesh_rotate(receive_horn_structure,rotation_vector3)
    receive_horn_structure = GF.mesh_translate(receive_horn_structure,np.asarray([0, 1.609, 0]))
    receiving_antenna_surface_coords = GF.mesh_rotate(receiving_antenna_surface_coords,rotation_vector1)
    #receiving_antenna_surface_coords = GF.mesh_rotate(receiving_antenna_surface_coords,rotation_vector3)
    receiving_antenna_surface_coords = GF.mesh_translate(receiving_antenna_surface_coords,np.asarray([0, 1.609, 0]))




.. GENERATED FROM PYTHON SOURCE LINES 82-85

Create Scattering Plate
--------------------------
Create a Scattering plate a source of multipath reflections

.. GENERATED FROM PYTHON SOURCE LINES 85-103

.. code-block:: Python


    reflectorplate, scatter_points = TL.meshedReflector(
        0.3, 0.3, 6e-3, wavelength * 0.5, sides="front"
    )

    position_vector = np.asarray([29e-3, 0.0, 0])
    rotation_vector1 = np.radians(np.asarray([0.0, 90.0, 0.0]))
    scatter_points = GF.mesh_rotate(
        scatter_points,
       rotation_vector1
    )
    reflectorplate = GF.mesh_rotate(
        reflectorplate,
        rotation_vector1
    )
    reflectorplate = GF.mesh_translate(reflectorplate,position_vector)
    scatter_points = GF.mesh_translate(scatter_points,position_vector)


.. GENERATED FROM PYTHON SOURCE LINES 104-107

Specify Reflection Angle
--------------------------
Rotate the scattering plate to the optimum angle for reflection from the transmitting to receiving horn

.. GENERATED FROM PYTHON SOURCE LINES 107-123

.. code-block:: Python


    plate_orientation_angle = 45.0

    rotation_vector = np.radians(np.asarray([0.0, 0.0, plate_orientation_angle]))
    scatter_points = GF.mesh_rotate(
        scatter_points,
        rotation_vector)
    reflectorplate = GF.mesh_rotate(
        reflectorplate,
        rotation_vector
    )

    from lyceanem.base_classes import structures

    blockers = structures([reflectorplate, receive_horn_structure, transmit_horn_structure])


.. GENERATED FROM PYTHON SOURCE LINES 124-126

Visualise the Scene Geometry
------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 126-137

.. code-block:: Python


    ## plot the mesh

    # Specify desired Transmit Polarisation
    # --------------------------------------
    # The transmit polarisation has a significant effect on the channel characteristics. In this example the transmit
    # horn will be vertically polarised, (e-vector aligned with the y direction)

    desired_E_axis = np.zeros((1, 3), dtype=np.float32)
    desired_E_axis[0, 1] = 1.0


.. GENERATED FROM PYTHON SOURCE LINES 138-144

Frequency Domain Scattering
----------------------------
Once the arrangement of interest has been setup, :func:`lyceanem.models.frequency_domain.calculate_scattering` can
be called, using raycasting to calculate the scattering parameters based upon the inputs. The scattering parameter
determines how many reflections will be considered. A value of 0 would mean only line of sight contributions will be
calculated, with 1 including single reflections, and 2 including double reflections as well.

.. GENERATED FROM PYTHON SOURCE LINES 144-179

.. code-block:: Python


    import lyceanem.models.frequency_domain as FD

    Ex, Ey, Ez = FD.calculate_scattering(
        aperture_coords=transmitting_antenna_surface_coords,
        sink_coords=receiving_antenna_surface_coords,
        antenna_solid=blockers,
        desired_E_axis=desired_E_axis,
        scatter_points=scatter_points,
        wavelength=wavelength,
        scattering=0,
        project_vectors=False,
        beta=(2*np.pi)/wavelength
    )
    Excuda, Eycuda, Ezcuda = FD.calculate_scattering(
        aperture_coords=transmitting_antenna_surface_coords,
        sink_coords=receiving_antenna_surface_coords,
        antenna_solid=blockers,
        desired_E_axis=desired_E_axis,
        scatter_points=scatter_points,
        wavelength=wavelength,
        scattering=0,
        project_vectors=False,
        beta=(2*np.pi)/wavelength,
        cuda=True

    )
    print("sumdiff",(np.sum((Ex-Excuda))))
    print("sumdiff",(np.sum((Ey-Eycuda))))
    print("sumdiff",(np.sum((Ez-Ezcuda))))
    np.testing.assert_allclose(Ex, Excuda, rtol=1e-5)
    np.testing.assert_allclose(Ey, Eycuda, rtol=1e-5)
    np.testing.assert_allclose(Ez, Ezcuda, rtol=1e-5)



.. GENERATED FROM PYTHON SOURCE LINES 180-185

Examine Scattering
---------------------
The resultant scattering is decomposed into the Ex,Ey,Ez components at the receiving antenna, by itself this is not
that interesting, so for this example we will rotate the reflector back, and then create a loop to step the reflector
through different angles from 0 to 90 degrees in 1 degree steps.

.. GENERATED FROM PYTHON SOURCE LINES 185-273

.. code-block:: Python





    angle_values = np.linspace(0, 90, 181)
    angle_increment = np.diff(angle_values)[0]
    responsex = np.zeros((len(angle_values)), dtype="complex")
    responsey = np.zeros((len(angle_values)), dtype="complex")
    responsez = np.zeros((len(angle_values)), dtype="complex")

    plate_orientation_angle = -45.0

    rotation_vector = np.radians(
        np.asarray([0.0, 0.0, plate_orientation_angle + 0.0])
    )
    scatter_points = GF.mesh_rotate(scatter_points,rotation_vector)
    reflectorplate = GF.mesh_rotate(reflectorplate,rotation_vector)

    from tqdm import tqdm

    for angle_inc in tqdm(range(len(angle_values))):
        rotation_vector = np.radians(np.asarray([0.0, 0.0, angle_values[angle_inc]]))
        scatter_points_temp = GF.mesh_rotate(scatter_points,rotation_vector)
        reflectorplate_temp = GF.mesh_rotate(reflectorplate,rotation_vector)
        blockers = structures([reflectorplate_temp, receive_horn_structure, transmit_horn_structure])
    
        Ex, Ey, Ez = FD.calculate_scattering(
            aperture_coords=transmitting_antenna_surface_coords,
            sink_coords=scatter_points_temp,
            antenna_solid=blockers,
            desired_E_axis=np.tile(desired_E_axis,[transmitting_antenna_surface_coords.points.shape[0],1]),
            scatter_points=scatter_points_temp,
            wavelength=wavelength,
            scattering=0,
            project_vectors=False,
            beta=(2*np.pi)/wavelength
        )
        scattered_field=np.array([Ex*scatter_points_temp.point_data['Area'], 
        Ey*scatter_points_temp.point_data['Area'], 
        Ez*scatter_points_temp.point_data['Area']]).transpose()
        #scatter_points_temp=update_electric_fields(scatter_points_temp, 
        #                                           Ex*scatter_points_temp.point_data['Area'], 
        #                                           Ey*scatter_points_temp.point_data['Area'], 
        #                                           Ez*scatter_points_temp.point_data['Area'])
        #scatter_points_temp=PoyntingVector(scatter_points_temp)
        #scatter_points_temp.point_data["Ex"]=np.abs(scatter_points_temp.point_data['Ex-Real']+1j*scatter_points_temp.point_data['Ex-Imag'])
        #scatter_points_temp.point_data["Ey"]=np.abs(scatter_points_temp.point_data['Ey-Real']+1j*scatter_points_temp.point_data['Ey-Imag'])
        #scatter_points_temp.point_data["Ez"]=np.abs(scatter_points_temp.point_data['Ez-Real']+1j*scatter_points_temp.point_data['Ez-Imag'])
        # plotter = pv.Plotter()
        # plotter.add_mesh(pv.from_meshio(reflectorplate_temp), color="grey")
        # plotter.add_mesh(pv.from_meshio(scatter_points_temp), scalars="Ey",clim=[0,0.0015])
        # plotter.add_mesh(pv.from_meshio(receive_horn_structure), color="blue")
        # plotter.add_mesh(pv.from_meshio(receiving_antenna_surface_coords), color="blue")
        # plotter.add_mesh(pv.from_meshio(transmit_horn_structure), color="red")
        # plotter.add_mesh(pv.from_meshio(transmitting_antenna_surface_coords), color="red")
        # plotter.add_axes_at_origin()
        # plotter.show()
    
        Ex2, Ey2, Ez2 = FD.calculate_scattering(
            aperture_coords=scatter_points_temp,
            sink_coords=receiving_antenna_surface_coords,
            antenna_solid=blockers,
            desired_E_axis=scattered_field,
            scatter_points=scatter_points_temp,
            wavelength=wavelength,
            scattering=0,
            project_vectors=False,
            beta=(2*np.pi)/wavelength
        )
        Ex3, Ey3, Ez3 = FD.calculate_scattering(
            aperture_coords=transmitting_antenna_surface_coords,
            sink_coords=receiving_antenna_surface_coords,
            antenna_solid=blockers,
            desired_E_axis=np.tile(desired_E_axis,[transmitting_antenna_surface_coords.points.shape[0],1]),
            scatter_points=scatter_points_temp,
            wavelength=wavelength,
            scattering=0,
            project_vectors=False,
            beta=(2*np.pi)/wavelength
        )
        responsex[angle_inc] = np.sum((Ex2+Ex3)*receiving_antenna_surface_coords.point_data["Area"])
        responsey[angle_inc] = np.sum((Ey2+Ey3)*receiving_antenna_surface_coords.point_data["Area"])
        responsez[angle_inc] = np.sum((Ez2+Ez3)*receiving_antenna_surface_coords.point_data["Area"])






.. GENERATED FROM PYTHON SOURCE LINES 274-277

Plot Normalised Response
----------------------------
Using matplotlib, plot the results

.. GENERATED FROM PYTHON SOURCE LINES 277-306

.. code-block:: Python


    import matplotlib.pyplot as plt

    normalised_max = np.max(
        np.array(
            [
                np.max(20 * np.log10(np.abs(responsex))),
                np.max(20 * np.log10(np.abs(responsey))),
                np.max(20 * np.log10(np.abs(responsez))),
            ]
        )
    )
    ExdB = 20 * np.log10(np.abs(responsex)) - normalised_max
    EydB = 20 * np.log10(np.abs(responsey)) - normalised_max
    EzdB = 20 * np.log10(np.abs(responsez)) - normalised_max

    fig, ax = plt.subplots()
    ax.plot(angle_values - 45, ExdB, label="Ex")
    ax.plot(angle_values - 45, EydB, label="Ey")
    ax.plot(angle_values - 45, EzdB, label="Ez")
    plt.xlabel("$\\theta_{N}$ (degrees)")
    plt.ylabel("Normalised Level (dB)")
    ax.set_ylim(-40.0, 0)
    ax.set_xlim(np.min(angle_values) - 45, np.max(angle_values) - 45)
    ax.set_xticks(np.linspace(np.min(angle_values) - 45, np.max(angle_values) - 45, 19))
    ax.set_yticks(np.linspace(-40, 0.0, 21))
    legend = ax.legend(loc="upper right", shadow=True)
    plt.grid()
    plt.show()


.. _sphx_glr_download_auto_examples_03_frequency_domain_channel_modelling.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: 03_frequency_domain_channel_modelling.ipynb <03_frequency_domain_channel_modelling.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: 03_frequency_domain_channel_modelling.py <03_frequency_domain_channel_modelling.py>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
